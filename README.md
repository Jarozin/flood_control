# Ход мыслей

Первый вопрос: как решать задачу проверки правил флуд контроля. Сразу же появляются две идеи:
1. Для каждого пользователя хранить счетчик обращений, то есть запись вида "id-пользователя" - "кол-во обращений". В таком случае сразу возникает вопрос контроля времени, прошедшего с момента n-ого обращения для удаления их по истечению времени N из правил. Проблема: если не хранить время добавления каждой отдельной записи, поддерживать точное корректное соблюдение правил скорее всего не получится, так что этот вариант не подходит (хотя можно попытаться хранить время старшей записи/среднее время/еще чего).

2. Для каждого вызова функции хранить отдельную запись с меткой времени и id пользователя. Для корректного следования правилам есть вся нужная информация, легко будет отсеивать нужное с помощью sql запросов. Единственная проблема - функция проверки на флуд скорее всего подразумевает частый вызов, об этом стоит помнить (из-за чего первый вариант вообще стоил того, чтобы его рассматривать - меньше записей = более высокая производительность). Так как после истечения срока, указанного в правилах, обращение нам становиться неинтересно, то для того, чтобы не хранить бесполезные данные и не замедлять бд, мы можем их удалять. Для этого есть несколько решений:
- Удалять бесполезные даннные перед каждой проверкой валидных обращений. Отсеивать по времени при проверке все равно придется, так как мы не знаем порядок, в котором эти запросы от нескольких приложений будет выполнять бд. В таком случае очевидно страдает производительность, ибо на каждый вызов функции необходимо будет дополнительно удалять данные, однако возможно это даст выигрыш при последующей фильтрации.
- Удалять данные раз в некоторый интервал времени. Данный подход скорее всего даст выигрыш во времени в начале интервала, однако к концу вполне может оказаться медленнее предыдущего варианта. Сам интервал нужно будет определять на практике, вполне возможно, что этот вариант окажется быстрее.
Оба варианта валидны, я реализовал первый в силу простоты реализации и тестирования. Вполне возможно, что при анализе производительности второй вариант выиграет при правильно подобранном интервале времени.

Для решения задачи проверки правил флуд контроля я выбрал второй вариант, ибо он более полно подходит под задачу.

В качестве общего хранилища данных я выбрал БД postgresql, так как я имею больший опыт работы с SQL, чем с NoSQL, он неплохо ложится на поставленную задачу, а postgresql - дефолтное решение в таком случае.

Конфигурация хранится в конфиге в виде json - его легко читать и писать, в golang с ним удобно работать. В нем хранятся параметры соединения с бд и параметры для алгоритма - время N в секундах и кол-во обращений K.

Имя файла конфига хранится в программе в виде константы, однако его можно было бы передавать в качестве аргумента командной строки. Так как сама задача в первую очередь состояла в реализации интерфейса, эти детали кажутся не очень важными.
